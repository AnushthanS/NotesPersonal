# Currency Formatting Problem
#format 
`NumberFormat <name> = NumberFormat.getCurrencyInstance(Locale custom/predefined);`
Then use `<name>.format(anyDouble);` to get the desired value.

Eg ->
- Custom Locale for India -

`Locale indLocale = new Locale("en","IN");`
`NumberFormat india = NumberFormat.getCurrencyInstance(indLocale);`
`System.out.println("India : "+india.format(double payment));`

The first tag "en" is for language, second tag "IN" for country.
Have to look these up for building a custom locale.

- Predefined locale -
`NumberFormat us = NumberFormat.getCurrencyInstance(Locale.US);`
`System.out.println("US : "+us.format(double payment));`
****
# Hash
- Hashing is to *convert key-value pair to an index* using a simple *modulus* function of array size.
- **Eg **- for an aray of size 10,   11%10=1 so 11 would be stored at index 1.
 - Obviously this will lead to collisions. Continuing the example above, 21%10 is also 1.
 ## Hash functions are generally of the following four types: 
 [gfg source](https://www.geeksforgeeks.org/hash-functions-and-list-types-of-hash-functions/)
 1. **Division method** - key mod n where n can be any (preferrably prime) number, or the size of the hash table itself.
 2. **Mid square method** - Taking the middle, say t, digits of the square of the key value, where t is the max number of digits in relation to table index.
 3. **Folding method** - The key is segmented into smaller values, like k = k1, k2, k3, .... and then these smaller parts are added.
 4. **Multiplication method** - We take a constant value A between 0 and 1, multiply it with our key, then take its fractional part. This is then multiplied by the size of the hash table and taken floor of to obtain a hash index.
 
 &nbsp
 
 #### There are multiple ways to deal with hash collisions : 
 1. *Open Addressing :*(closed hashing) Store the colliding values in the next open slot adn shift the following elements one index up.
 2. *LinkedHashSet : * Make a linked list at the collision point to store all the values of the same index. This method is *Closed Addressing*(open hashing).

## Open Addressing - 
Has three popular methods: 
1. **Linear Probing** -  Popular with modulus hash functions, the index obtained after, say, k mod n is again passed through hash function. Then we check for collision. **If index mod n is pre-occupied, we check (index +1) mod n** and the process is repeated until we find an empty slot.
2. **Quadratic Probing** - We add something to the answer of original hash function to make it quadratic, and use the same formula again.
	- say `h(x) = x mod n ; hFinal(x) = (h(x) + i^2) mod n`, i denotes range of indices.
	- take value of i from 0 to n-1 whenever a collision is encountered.
3. **Double Hashing** - We take 2 hash functions. In case a colliison occurs, we apply the second hash function.
	-	Eg- say we have to functions h1 and h2. If a collision is encountered from h1, we take (h1 + h2) mod n, then (h1 + 2h2) mod n, (h1 + 3h2) mod n, and so on until we find an empty index.

** We take mod after obtaining hash value in addressing just to make sure that no value greater or equal to the size of the table is obtained**

&nbsp

## Closed Addressing
-	**Chaining** - A linked list is formed at the spot of collision.